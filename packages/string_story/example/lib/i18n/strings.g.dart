/// Generated file. Do not edit.
///
/// Source: lib/i18n/json
/// To regenerate, run: `dart run slang`
///
/// Locales: 2
/// Strings: 28 (14 per locale)

// coverage:ignore-file
// ignore_for_file: type=lint, unused_import

import 'package:flutter/widgets.dart';
import 'package:intl/intl.dart';
import 'package:slang/generated.dart';
import 'package:slang/overrides.dart';
import 'package:slang_flutter/slang_flutter.dart';
export 'package:slang_flutter/slang_flutter.dart';

import 'strings_fr.g.dart' deferred as l_fr;
part 'strings_en.g.dart';

/// Generated by the "Translation Overrides" feature.
/// This config is needed to recreate the translation model exactly
/// the same way as this file was created.
final _buildConfig = BuildModelConfig(
  fallbackStrategy: FallbackStrategy.none,
  keyCase: null,
  keyMapCase: null,
  paramCase: null,
  sanitization: SanitizationConfig(
      enabled: true, prefix: 'k', caseStyle: CaseStyle.camel),
  stringInterpolation: StringInterpolation.dart,
  maps: [],
  pluralAuto: PluralAuto.cardinal,
  pluralParameter: 'n',
  pluralCardinal: [],
  pluralOrdinal: [],
  contexts: [],
  interfaces: [], // currently not supported
  generateEnum: true,
);

/// Supported locales.
///
/// Usage:
/// - LocaleSettings.setLocale(AppLocale.en) // set locale
/// - Locale locale = AppLocale.en.flutterLocale // get flutter locale from enum
/// - if (LocaleSettings.currentLocale == AppLocale.en) // locale check
enum AppLocale with BaseAppLocale<AppLocale, Translations> {
  en(languageCode: 'en'),
  fr(languageCode: 'fr');

  const AppLocale({
    required this.languageCode,
    this.scriptCode, // ignore: unused_element, unused_element_parameter
    this.countryCode, // ignore: unused_element, unused_element_parameter
  });

  @override
  final String languageCode;
  @override
  final String? scriptCode;
  @override
  final String? countryCode;

  @override
  Future<Translations> build({
    Map<String, Node>? overrides,
    PluralResolver? cardinalResolver,
    PluralResolver? ordinalResolver,
  }) async {
    switch (this) {
      case AppLocale.en:
        return TranslationsEn(
          overrides: overrides,
          cardinalResolver: cardinalResolver,
          ordinalResolver: ordinalResolver,
        );
      case AppLocale.fr:
        await l_fr.loadLibrary();
        return l_fr.TranslationsFr(
          overrides: overrides,
          cardinalResolver: cardinalResolver,
          ordinalResolver: ordinalResolver,
        );
    }
  }

  @override
  Translations buildSync({
    Map<String, Node>? overrides,
    PluralResolver? cardinalResolver,
    PluralResolver? ordinalResolver,
  }) {
    switch (this) {
      case AppLocale.en:
        return TranslationsEn(
          overrides: overrides,
          cardinalResolver: cardinalResolver,
          ordinalResolver: ordinalResolver,
        );
      case AppLocale.fr:
        return l_fr.TranslationsFr(
          overrides: overrides,
          cardinalResolver: cardinalResolver,
          ordinalResolver: ordinalResolver,
        );
    }
  }
}

/// Provides utility functions without any side effects.
class AppLocaleUtils extends BaseAppLocaleUtils<AppLocale, Translations> {
  AppLocaleUtils._()
      : super(
          baseLocale: AppLocale.en,
          locales: AppLocale.values,
          buildConfig: _buildConfig,
        );

  static final instance = AppLocaleUtils._();

  // static aliases (checkout base methods for documentation)
  static AppLocale parse(String rawLocale) => instance.parse(rawLocale);
  static AppLocale parseLocaleParts(
          {required String languageCode,
          String? scriptCode,
          String? countryCode}) =>
      instance.parseLocaleParts(
          languageCode: languageCode,
          scriptCode: scriptCode,
          countryCode: countryCode);
  static AppLocale findDeviceLocale() => instance.findDeviceLocale();
  static List<Locale> get supportedLocales => instance.supportedLocales;
  static List<String> get supportedLocalesRaw => instance.supportedLocalesRaw;
  static Future<Translations> buildWithOverrides(
          {required AppLocale locale,
          required FileType fileType,
          required String content,
          PluralResolver? cardinalResolver,
          PluralResolver? ordinalResolver}) =>
      instance.buildWithOverrides(
          locale: locale,
          fileType: fileType,
          content: content,
          cardinalResolver: cardinalResolver,
          ordinalResolver: ordinalResolver);
  static Future<Translations> buildWithOverridesFromMap(
          {required AppLocale locale,
          required bool isFlatMap,
          required Map map,
          PluralResolver? cardinalResolver,
          PluralResolver? ordinalResolver}) =>
      instance.buildWithOverridesFromMap(
          locale: locale,
          isFlatMap: isFlatMap,
          map: map,
          cardinalResolver: cardinalResolver,
          ordinalResolver: ordinalResolver);
  static Translations buildWithOverridesSync(
          {required AppLocale locale,
          required FileType fileType,
          required String content,
          PluralResolver? cardinalResolver,
          PluralResolver? ordinalResolver}) =>
      instance.buildWithOverridesSync(
          locale: locale,
          fileType: fileType,
          content: content,
          cardinalResolver: cardinalResolver,
          ordinalResolver: ordinalResolver);
  static Translations buildWithOverridesFromMapSync(
          {required AppLocale locale,
          required bool isFlatMap,
          required Map map,
          PluralResolver? cardinalResolver,
          PluralResolver? ordinalResolver}) =>
      instance.buildWithOverridesFromMapSync(
          locale: locale,
          isFlatMap: isFlatMap,
          map: map,
          cardinalResolver: cardinalResolver,
          ordinalResolver: ordinalResolver);
}
