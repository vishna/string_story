// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'slang_editor_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

SlangEditorState _$SlangEditorStateFromJson(Map<String, dynamic> json) {
  return _SlangEditorState.fromJson(json);
}

/// @nodoc
mixin _$SlangEditorState {
  /// current live locale file
  Map<String, dynamic> get slangJson => throw _privateConstructorUsedError;

  /// current live locale file (scoped)
  Map<String, dynamic> get slangScopedJson =>
      throw _privateConstructorUsedError;

  /// the base language unmodified locale file
  Map<String, dynamic> get baseSlangJson => throw _privateConstructorUsedError;

  /// current language unmodified locale file
  Map<String, dynamic> get ovSlangJson => throw _privateConstructorUsedError;
  Set<String> get scopedKeys => throw _privateConstructorUsedError;
  List<String> get diffKeys => throw _privateConstructorUsedError;
  String? get selectedKey => throw _privateConstructorUsedError;
  String? get scrollToKey => throw _privateConstructorUsedError;
  bool get disablePreviewFocus => throw _privateConstructorUsedError;
  List<String> get searchResults => throw _privateConstructorUsedError;
  double get progress => throw _privateConstructorUsedError;

  /// Serializes this SlangEditorState to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of SlangEditorState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SlangEditorStateCopyWith<SlangEditorState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SlangEditorStateCopyWith<$Res> {
  factory $SlangEditorStateCopyWith(
          SlangEditorState value, $Res Function(SlangEditorState) then) =
      _$SlangEditorStateCopyWithImpl<$Res, SlangEditorState>;
  @useResult
  $Res call(
      {Map<String, dynamic> slangJson,
      Map<String, dynamic> slangScopedJson,
      Map<String, dynamic> baseSlangJson,
      Map<String, dynamic> ovSlangJson,
      Set<String> scopedKeys,
      List<String> diffKeys,
      String? selectedKey,
      String? scrollToKey,
      bool disablePreviewFocus,
      List<String> searchResults,
      double progress});
}

/// @nodoc
class _$SlangEditorStateCopyWithImpl<$Res, $Val extends SlangEditorState>
    implements $SlangEditorStateCopyWith<$Res> {
  _$SlangEditorStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SlangEditorState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? slangJson = null,
    Object? slangScopedJson = null,
    Object? baseSlangJson = null,
    Object? ovSlangJson = null,
    Object? scopedKeys = null,
    Object? diffKeys = null,
    Object? selectedKey = freezed,
    Object? scrollToKey = freezed,
    Object? disablePreviewFocus = null,
    Object? searchResults = null,
    Object? progress = null,
  }) {
    return _then(_value.copyWith(
      slangJson: null == slangJson
          ? _value.slangJson
          : slangJson // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      slangScopedJson: null == slangScopedJson
          ? _value.slangScopedJson
          : slangScopedJson // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      baseSlangJson: null == baseSlangJson
          ? _value.baseSlangJson
          : baseSlangJson // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      ovSlangJson: null == ovSlangJson
          ? _value.ovSlangJson
          : ovSlangJson // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      scopedKeys: null == scopedKeys
          ? _value.scopedKeys
          : scopedKeys // ignore: cast_nullable_to_non_nullable
              as Set<String>,
      diffKeys: null == diffKeys
          ? _value.diffKeys
          : diffKeys // ignore: cast_nullable_to_non_nullable
              as List<String>,
      selectedKey: freezed == selectedKey
          ? _value.selectedKey
          : selectedKey // ignore: cast_nullable_to_non_nullable
              as String?,
      scrollToKey: freezed == scrollToKey
          ? _value.scrollToKey
          : scrollToKey // ignore: cast_nullable_to_non_nullable
              as String?,
      disablePreviewFocus: null == disablePreviewFocus
          ? _value.disablePreviewFocus
          : disablePreviewFocus // ignore: cast_nullable_to_non_nullable
              as bool,
      searchResults: null == searchResults
          ? _value.searchResults
          : searchResults // ignore: cast_nullable_to_non_nullable
              as List<String>,
      progress: null == progress
          ? _value.progress
          : progress // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SlangEditorStateImplCopyWith<$Res>
    implements $SlangEditorStateCopyWith<$Res> {
  factory _$$SlangEditorStateImplCopyWith(_$SlangEditorStateImpl value,
          $Res Function(_$SlangEditorStateImpl) then) =
      __$$SlangEditorStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Map<String, dynamic> slangJson,
      Map<String, dynamic> slangScopedJson,
      Map<String, dynamic> baseSlangJson,
      Map<String, dynamic> ovSlangJson,
      Set<String> scopedKeys,
      List<String> diffKeys,
      String? selectedKey,
      String? scrollToKey,
      bool disablePreviewFocus,
      List<String> searchResults,
      double progress});
}

/// @nodoc
class __$$SlangEditorStateImplCopyWithImpl<$Res>
    extends _$SlangEditorStateCopyWithImpl<$Res, _$SlangEditorStateImpl>
    implements _$$SlangEditorStateImplCopyWith<$Res> {
  __$$SlangEditorStateImplCopyWithImpl(_$SlangEditorStateImpl _value,
      $Res Function(_$SlangEditorStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of SlangEditorState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? slangJson = null,
    Object? slangScopedJson = null,
    Object? baseSlangJson = null,
    Object? ovSlangJson = null,
    Object? scopedKeys = null,
    Object? diffKeys = null,
    Object? selectedKey = freezed,
    Object? scrollToKey = freezed,
    Object? disablePreviewFocus = null,
    Object? searchResults = null,
    Object? progress = null,
  }) {
    return _then(_$SlangEditorStateImpl(
      slangJson: null == slangJson
          ? _value._slangJson
          : slangJson // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      slangScopedJson: null == slangScopedJson
          ? _value._slangScopedJson
          : slangScopedJson // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      baseSlangJson: null == baseSlangJson
          ? _value._baseSlangJson
          : baseSlangJson // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      ovSlangJson: null == ovSlangJson
          ? _value._ovSlangJson
          : ovSlangJson // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      scopedKeys: null == scopedKeys
          ? _value._scopedKeys
          : scopedKeys // ignore: cast_nullable_to_non_nullable
              as Set<String>,
      diffKeys: null == diffKeys
          ? _value._diffKeys
          : diffKeys // ignore: cast_nullable_to_non_nullable
              as List<String>,
      selectedKey: freezed == selectedKey
          ? _value.selectedKey
          : selectedKey // ignore: cast_nullable_to_non_nullable
              as String?,
      scrollToKey: freezed == scrollToKey
          ? _value.scrollToKey
          : scrollToKey // ignore: cast_nullable_to_non_nullable
              as String?,
      disablePreviewFocus: null == disablePreviewFocus
          ? _value.disablePreviewFocus
          : disablePreviewFocus // ignore: cast_nullable_to_non_nullable
              as bool,
      searchResults: null == searchResults
          ? _value._searchResults
          : searchResults // ignore: cast_nullable_to_non_nullable
              as List<String>,
      progress: null == progress
          ? _value.progress
          : progress // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SlangEditorStateImpl implements _SlangEditorState {
  _$SlangEditorStateImpl(
      {final Map<String, dynamic> slangJson = const {},
      final Map<String, dynamic> slangScopedJson = const {},
      final Map<String, dynamic> baseSlangJson = const {},
      final Map<String, dynamic> ovSlangJson = const {},
      final Set<String> scopedKeys = const {},
      final List<String> diffKeys = const [],
      this.selectedKey,
      this.scrollToKey,
      this.disablePreviewFocus = true,
      final List<String> searchResults = const [],
      this.progress = 0.0})
      : _slangJson = slangJson,
        _slangScopedJson = slangScopedJson,
        _baseSlangJson = baseSlangJson,
        _ovSlangJson = ovSlangJson,
        _scopedKeys = scopedKeys,
        _diffKeys = diffKeys,
        _searchResults = searchResults;

  factory _$SlangEditorStateImpl.fromJson(Map<String, dynamic> json) =>
      _$$SlangEditorStateImplFromJson(json);

  /// current live locale file
  final Map<String, dynamic> _slangJson;

  /// current live locale file
  @override
  @JsonKey()
  Map<String, dynamic> get slangJson {
    if (_slangJson is EqualUnmodifiableMapView) return _slangJson;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_slangJson);
  }

  /// current live locale file (scoped)
  final Map<String, dynamic> _slangScopedJson;

  /// current live locale file (scoped)
  @override
  @JsonKey()
  Map<String, dynamic> get slangScopedJson {
    if (_slangScopedJson is EqualUnmodifiableMapView) return _slangScopedJson;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_slangScopedJson);
  }

  /// the base language unmodified locale file
  final Map<String, dynamic> _baseSlangJson;

  /// the base language unmodified locale file
  @override
  @JsonKey()
  Map<String, dynamic> get baseSlangJson {
    if (_baseSlangJson is EqualUnmodifiableMapView) return _baseSlangJson;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_baseSlangJson);
  }

  /// current language unmodified locale file
  final Map<String, dynamic> _ovSlangJson;

  /// current language unmodified locale file
  @override
  @JsonKey()
  Map<String, dynamic> get ovSlangJson {
    if (_ovSlangJson is EqualUnmodifiableMapView) return _ovSlangJson;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_ovSlangJson);
  }

  final Set<String> _scopedKeys;
  @override
  @JsonKey()
  Set<String> get scopedKeys {
    if (_scopedKeys is EqualUnmodifiableSetView) return _scopedKeys;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_scopedKeys);
  }

  final List<String> _diffKeys;
  @override
  @JsonKey()
  List<String> get diffKeys {
    if (_diffKeys is EqualUnmodifiableListView) return _diffKeys;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_diffKeys);
  }

  @override
  final String? selectedKey;
  @override
  final String? scrollToKey;
  @override
  @JsonKey()
  final bool disablePreviewFocus;
  final List<String> _searchResults;
  @override
  @JsonKey()
  List<String> get searchResults {
    if (_searchResults is EqualUnmodifiableListView) return _searchResults;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_searchResults);
  }

  @override
  @JsonKey()
  final double progress;

  @override
  String toString() {
    return 'SlangEditorState(slangJson: $slangJson, slangScopedJson: $slangScopedJson, baseSlangJson: $baseSlangJson, ovSlangJson: $ovSlangJson, scopedKeys: $scopedKeys, diffKeys: $diffKeys, selectedKey: $selectedKey, scrollToKey: $scrollToKey, disablePreviewFocus: $disablePreviewFocus, searchResults: $searchResults, progress: $progress)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SlangEditorStateImpl &&
            const DeepCollectionEquality()
                .equals(other._slangJson, _slangJson) &&
            const DeepCollectionEquality()
                .equals(other._slangScopedJson, _slangScopedJson) &&
            const DeepCollectionEquality()
                .equals(other._baseSlangJson, _baseSlangJson) &&
            const DeepCollectionEquality()
                .equals(other._ovSlangJson, _ovSlangJson) &&
            const DeepCollectionEquality()
                .equals(other._scopedKeys, _scopedKeys) &&
            const DeepCollectionEquality().equals(other._diffKeys, _diffKeys) &&
            (identical(other.selectedKey, selectedKey) ||
                other.selectedKey == selectedKey) &&
            (identical(other.scrollToKey, scrollToKey) ||
                other.scrollToKey == scrollToKey) &&
            (identical(other.disablePreviewFocus, disablePreviewFocus) ||
                other.disablePreviewFocus == disablePreviewFocus) &&
            const DeepCollectionEquality()
                .equals(other._searchResults, _searchResults) &&
            (identical(other.progress, progress) ||
                other.progress == progress));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_slangJson),
      const DeepCollectionEquality().hash(_slangScopedJson),
      const DeepCollectionEquality().hash(_baseSlangJson),
      const DeepCollectionEquality().hash(_ovSlangJson),
      const DeepCollectionEquality().hash(_scopedKeys),
      const DeepCollectionEquality().hash(_diffKeys),
      selectedKey,
      scrollToKey,
      disablePreviewFocus,
      const DeepCollectionEquality().hash(_searchResults),
      progress);

  /// Create a copy of SlangEditorState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SlangEditorStateImplCopyWith<_$SlangEditorStateImpl> get copyWith =>
      __$$SlangEditorStateImplCopyWithImpl<_$SlangEditorStateImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SlangEditorStateImplToJson(
      this,
    );
  }
}

abstract class _SlangEditorState implements SlangEditorState {
  factory _SlangEditorState(
      {final Map<String, dynamic> slangJson,
      final Map<String, dynamic> slangScopedJson,
      final Map<String, dynamic> baseSlangJson,
      final Map<String, dynamic> ovSlangJson,
      final Set<String> scopedKeys,
      final List<String> diffKeys,
      final String? selectedKey,
      final String? scrollToKey,
      final bool disablePreviewFocus,
      final List<String> searchResults,
      final double progress}) = _$SlangEditorStateImpl;

  factory _SlangEditorState.fromJson(Map<String, dynamic> json) =
      _$SlangEditorStateImpl.fromJson;

  /// current live locale file
  @override
  Map<String, dynamic> get slangJson;

  /// current live locale file (scoped)
  @override
  Map<String, dynamic> get slangScopedJson;

  /// the base language unmodified locale file
  @override
  Map<String, dynamic> get baseSlangJson;

  /// current language unmodified locale file
  @override
  Map<String, dynamic> get ovSlangJson;
  @override
  Set<String> get scopedKeys;
  @override
  List<String> get diffKeys;
  @override
  String? get selectedKey;
  @override
  String? get scrollToKey;
  @override
  bool get disablePreviewFocus;
  @override
  List<String> get searchResults;
  @override
  double get progress;

  /// Create a copy of SlangEditorState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SlangEditorStateImplCopyWith<_$SlangEditorStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
